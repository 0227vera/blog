---
sidebarDepth: 2
collapsable: true
---

# 在 html 中遇到好的问题和一些基本的问题

## html 语义化

什么是语义化？ 用人话讲就是用合理正确的标签来展示内容，比如 h1~h6 表示标题

好处有：

1. 易于代码维护，样式丢失的时候能够让页面具有清晰的结构

2. 利于 SEO，搜索引擎根据标签来确定上下文和各个关键字的权重

3. 方便其他设备解析，如盲人阅读器根据语义渲染网页

4. 有利于开发和维护，语义话更具可读性，代码更好维护，与 CSS3 关系更和谐

## doctype 有什么用

doctype 是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型来定义解析文档

声明是用来指示 web 浏览器关于页面使用哪个 html 版本进行编写的指令，必须在文档的第一行，位于 html 标签之前

浏览器本身分为两种模式：标准模式和怪异模式，浏览器通过 doctype 来区分这两种模式，如果没有 doctype 浏览器就会进入怪异模式，在这个模式下面，样式和标准模式存在差异，而 dom 标准和 html 标准规定标准模式下的行为，没有对怪异模式的规定，所以不同浏览器在怪异模式下面的的处理是不同的

## css 引入和 js 引入

为什么最好把`<link>`标签放在 head 之间？为什么最好把`<script>`放在`</body>`之后

1. 把 link 标签放在 head 之间是规范要求的内容，如果不放在头部，一旦浏览器阻止渲染，会发生空白页面或者没有样式的内容

2. script 脚本在下载和执行期间会阻止 html 解析，把 script 放在底部，保证 html 首先完成解析，将页面尽早呈现给用户

## 渐进式渲染

渐进式渲染适用于提高网页性能（特别是用户感知的加载速度），以尽快呈现页面的技术

在早之前的互联网带宽较小的时代里面，渐进式的技术可想而知需求很大，当下在移动端网络不稳定的情况下面也是有必要的

eg:

1. 图片懒加载技术

2. 确定显示内容的优先级（分层次渲染）------为了尽快将页面呈现用户，页面只包含基本的最少量的 css、脚本和内容，这一块像 vue 这样的框架已经做的比较完善了，但是在 vue 中有时候因为样式过多首次加载较慢的情况可以在 webpack 中配置（<font color=red>纠正：这样并不会增加首屏加载速度[原文](https://cli.vuejs.org/zh/guide/html-and-static-assets.html#preload)</font>）

```js
// 移除 prefetch 插件
config.plugins.delete("prefetch");
// 移除 preload 插件
config.plugins.delete("preload");
```

## reflow 和 repaint

1. reflow：当涉及到 dom 节点的布局属性发生变化时候，就会重新计算属性，浏览器会重新描绘相应的元素，此过程叫做 reflow（回流或重排）

2. repaint：当影响 dom 元素的可见性的属性发生变化的时候（eg：color、font），浏览器会重新描绘相应的元素，此过程叫做 repaint（重绘），因此重排必然会引起重绘

eg： 会引起 reflow 和 repaint 的一些操作

- 窗口大小变化
- 字体大小变化
- 样式表变化
- 元素内容变化，尤其是输入控件
- css 伪类变化，在交互中是必然会发生
- 所有的 dom 操作
- width、clientWidth、scrollTop 等布局高度的重新计算

如何在研发的过程注意这些点

1. 不要逐条行内样式修改，使用 className

2. 避免频繁操作 dom 特别是在 jq 时代

3. 不要频繁读取元素的集合属性，但是如果交互确实需要去做的时候也没有办法（我自己认为的哈）

4. 绝对定位的脱离文档流，避免引起父元素以及后续元素大量的回流（特别在元素的拖动中）

## href 和 src 的区别

1. href 标识超文本引用，用在 link 和 a 等元素上，href 是引用和页面关联，是在当前元素和引用资源之间建立联系；css 中的 href 是可以并行下载的并且不会停止当前对文档的处理，所以会推荐用 link 引入 css 为不是@import

2. scr 标识引入资源，在 img、script、iframe 上是必不可少的一部分；scr 会暂停其他的卸载和处理（图片不会暂停其他下载），直到该资源加载、编译、执行完成，这就是为什么建议把 js 脚本放在底部而不是头部

## 浏览器的渲染过程

1. DNS 的查询(也就是根据域名去找对应的 ip 地址)
2. TCP 的连接(连接建立、数据传送以及连接释放)
3. HTTP 请求即响应
4. 服务端响应
5. 客户端渲染

渲染过程如下：

1. 解析 html 生成 dom 树
2. 解析 css 生成 cssom 树
3. 将 dom 树和 cssom 树规则合并在一起生成渲染树
4. 遍历渲染树开始布局，计算每一个节点的位置信息等
5. 将渲染树每个节点绘制到屏幕

## 浏览器的缓存机制

浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 抱文的缓存标识进行的，HTTP 抱文分为两种：

1. HTTP 请求(Request)抱文
2. HTTP 响应(Response)抱文

浏览器与服务器通信的方式为应答模式，即为：[浏览器发起 HTTP 请求 – 服务器响应该](/posts/internet/TCP的3次握手)请求，那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中

1. 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
2. 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

缓存分为强制缓存和协商缓存

- 强制缓存

  - HTTP 响应报文中的 expires--`expires: Wed, 21 Oct 2020 03:25:41 GMT`，这个是一个绝对时间，在指定的时间前请求缓存生效
  - HTTP 响应报文中的 Cache-Control--`cache-control: max-age=600`，这是一个相对值，单位 s，也就是 600s 之内再次请求会直接使用缓存，强制缓存生效
    > 在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control 相比于 expires 是更好的选择，所以同时存在时，只有 Cache-Control 生效

  强制缓存的返回状态码为： 200

  但是看返回值中的 size 栏中有`from memory cache`和`from disk cache`：分别是内存中的缓存和硬盘中的缓存，浏览器对与两者的读取顺序是： memory -> disk

  1. 内存缓存：快速读取（直接写入进程的内存中，方便下次使用和快速读取）和时效性（也就是一旦关闭进程关闭，内存就会清空）

  2. 直接将缓存写入硬盘文件中，读取缓存需要对硬盘文件进行 I/O 操作，读取是复杂的，速度也是比内存慢的

- 协商缓存(协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程)
  - 协商缓存生效，返回 304
  - 协商缓存失效，返回 200 和请求结果结果

协商缓存的表示在响应的报文中为：`Last-Modified / If-Modified-Since` 和 `Etag / If-None-Match`， 其中 `Etag / If-None-Match` > `Last-Modified / If-Modified-Since`

- 也就是说： 强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存

![图解](../../.vuepress/public/img/cache.png)

## 浏览器的垃圾回收机制

## iframe 框架优缺点

优点：

1. iframe 能够 100%保证嵌入的网页展示

2. 如果多个网页引入 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的修改，方便快捷（有点组件的感觉哈）

3. 组件化的使用，头部和尾部的使用

4. 遇到第三方插件加载缓慢的时候可以使用 iframe

缺点：

1. 搜索引擎无法解读 iframe 里面的页面内容

2. 滚动条的混乱

3. 使用框架架构时，保证正确的导航链接

4. iframe 页面会增加服务器的 http 请求

使用 iframe 怎么说呢？我一般是能不用就不用的，但是有些时候又是必须要去使用的

## label 标签作用和使用

label 标签通常是写在表单内，他关联一个控件，使用 label 可以实现点击文字选取对应的控件

```html
<input type="checkbox" id="test" /> <label for="test">test</label>
```

## DOM 和 BOM 的区别

1. dom 是文档对象模型，dom 是为了操作文档出现的 API，document 是其的一个对象，dom 和文档有关，此处的文档指的是网页，也就是 html 文档，dom 和浏览器无关，他关注的是网页本身的内容

2. bom 是浏览器的对象模型，bom 是为了操作浏览器出现的 API，window 是其的一个对象，window 对象即为 js 访问浏览器的 API，同时在 ECMAScript 中充当 Global 对象

<back-to-top />

<gitask />
