---
sidebarDepth: 2
collapsable: true
---

# 面试

## target 和 currentTarget 区别

1. target 返回触发事件的元素

2. currentTarget 返回绑定事件的元素

## 事件委托

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

## 事件循环

事件循环是一个单线程的循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务中有回调函数，则将回调函数出堆并推送到调用堆栈中执行

[详情+例子](./#事件循环机制之宏任务-队列-和微任务-队列)

## 如何自定义事件（原生 js 提供的事件）

1. createEvent，设置事件类型，是 html 事件还是鼠标事件
2. initEvent，初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件
3. dispatchEvent，触发事件

## 基础数据类型，原始数据类型，引用数据类型，数据类型判断

[跳转](./#js的数据类型及其检测)

## var、let 和 const 的问题

[跳转](./#变量定义-var、let、const)

## 数组去重

[跳转](./基本算法.html#_3-1数组去重)

## 对象的深拷贝和浅拷贝

[跳转](./工具函数.html#_13-object-assign-对象属性的复制，浅拷贝)

## prototype 和 proto 的关系式什么

所有的对象都有 proto 属性，他指向对象的构造函数的 prototype

## new 一个对象经历了什么，手写 new 关键字

[跳转](./#面向对象)

## this

[跳转](./#面向对象)

## bind、call、apply 区别

call 和 apply 其实是一样的，区别就在于传参时参数是一个一个传或者是以一个数组的方式来传。call 和 apply 都是在调用时生效，改变调用者的 this 指向。

bind 也是改变 this 指向，不过不是在调用时生效，而是返回一个新函数。

## 继承问题

[跳转](./#面向对象)

## 打印值

```js
function Person () {
  getAge = function () {
    console.log(10)
  }
  return this  // 这个地方this的作用：在3的是是把this指向全局对象
}
Person.getAge = function () {
  console.log(20)
}
Person.prototype.getAge = function () {
  console.log(30)
}
var getAge = function () {
  console.log(40)
}
function getAge () {
  console.log(50)
}
Person.getAge()             // 1.  20

getAge()                    // 2.  40

Person().getAge()           // 3. 10

getAge()                    // 4. 10

new Person.getAge()         // 5. 20

new Person().getAge()       // 6. 30

new new Person().getAge()   // 7. 30

new (new Person().getAge) () // 8. 30  对7的解释
```

## 闭包问题

闭包是指有权访问另一个函数作用域中的变量的函数。桥梁的概念

## cookie、localStorage、sessionStorage 区别

| 特性           | cookie                                                                       | localStorage       | sessionStorage                   |
| -------------- | ---------------------------------------------------------------------------- | ------------------ | -------------------------------- |
| 由谁初始化     | 客户端或服务器，服务器可以使用 Set-Cookie 请求头。                           | 客户端             | 客户端                           |
| 数据的生命周期 | 一般由服务器生成，可设置失效时间，如果在浏览器生成，默认是关闭浏览器之后失效 | 永久保存，可清除   | 仅在当前会话有效，关闭页面后清除 |
| 存放数据大小   | 4KB                                                                          | 5MB                | 5MB                              |
| 与服务器通信   | 每次都会携带在 HTTP 头中，如果使用 cookie 保存过多数据会带来性能问题         | 仅在客户端保存     | 仅在客户端保存                   |
| 用途           | 一般由服务器生成，用于标识用户身份                                           | 用于浏览器缓存数据 | 用于浏览器缓存数据               |
| 访问权限       | 任意窗口                                                                     | 任意窗口           | 当前页面窗口                     |

## 防抖和节流

1. 防抖(debounce)：在函数需要频繁触发时，只有当有足够空闲的时间时，才执行一次。就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。

2. 节流(thorttle)：预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现 bug。

区别：在发生持续触发事件时，防抖设置事件延迟并在空闲时间去触发事件，而节流则是隔一定的时间触发一次。

## Ajax

Ajax 是使用客户端上的许多 web 技术，创建一个 web 应用的一种 web 开发技术，借助 Ajax，web 应用可以异步（在后台）向服务器发送数据和从服务器检索数据，而不会干扰现有页面的显示和行为，将数据交换与表示层分离，Ajax 允许网页和扩展 web 应用程序动态更改内容，而无需重新加载整个页面，实际上，现在通常将 json 替换为 xml，因为 js 对 json 有原生优势

使用 xml 如何封装

```js
let xmlhttp;
if (window.XMLHttpRequest) {
  xmlhttp = new XMLHttpRequest();
} else {
  xmlhttp = ActiveXObject("Microsoft.XMLHTTP"); // IE5,6
}
xmlhttp.onreadystatechange = () => {
  xmlhttp.readyState === 4 &&
  xmlhttp.status === 200 &&
  document.getElementById("myDiv").innerHTML = xmlhttp.responseText;
};

xmlhttp.open("GET", "/xxx/xxx.txt", true);
xmlhttp.send();
```

使用 Ajax 的优缺点

优点：

1. 交互性更好，来自服务端的新内容可以动态更新，无需重新加载整个页面
2. 减少与服务器的连接，因为脚本和样式只需要被请求一次
3. 状态可以维护在一个页面，js 变量和 dom 状态将得到保持，因为主容器未被重新加载
4. 基本上包括大部分 SPA 的优点

缺点：

1. 动态网页很难收藏
2. 网页 js 不能使用，则 Ajax 也不能使用
3. 有些网络爬虫不执行 js，也不会看到 js 的加载内容
4. 基本上也包括了大部分 SPA 的缺点

比较一下 Ajax 和 Fetch

1. Fetch 书写比 ajax 简单
2. fetch 基于 Promise，不可以取消，因为 Promise 做不到
3. 在默认情况下面，fetch 不接受和发送 cookies
4. fetch 只对网络报错
5. 兼容性就不用多说了

ajax 中的 post 提交数据

1. 默认是：application/x-www-form-urlencoded（可以加上 ;charset=UTF-8）key-value 字符串的提交

2. 有文件上传时候：multipart/form-data

3. 现代一点的是：application/json，可以传送各种格式的数据

## 同源策略

同源策略可防止 js 发生跨域请求，源被定义为 URI，主机名和端口号的组合。此策略可防止页面的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据

## 跨域

1. jsonp: 通过回调函数的形式，执行请求之后的方法，思想来源 script 的 src

2. 后端配置允许访问（access-control-allow-origin）请求头的设置

3. webpack 中的 proxyTable

## HTTP 问题

[跳转](/posts/internet/)

## 基本算法

[跳转](./基本算法.html#_1-排序算法)

## forEach return 的问题

我们知道`forEach` 中 `return`是无法终止循环的，但是有些之后我们又想要他停下来，又不想使用`for`循环写，有方法吗？那必须有，如果没有我还说个啥，不说了，上代码

```js
/**
 * 需求：打印3以下的数字3，之后就循环终止
 * 除了for循环，我能想到有如下三种
 */

let arr = [1, 2, 3, 4, 5, 6, 7];
// 1. forEach + try catch
try {
  arr.forEach((item) => {
    if (item > 3) throw "循环终止";
    else console.log(item);
  });
} catch (error) {
  console.log(error);
}
// 2. 利用every return false就终止的特性
arr.every((item) => {
  if (item > 3) {
    console.log("循环终止");
    return false;
  } else {
    console.log(item);
    return true;
  }
});
// 3. 利用some return true就终止的特性
arr.some((item) => {
  if (item > 3) {
    console.log("循环终止");
    return true;
  } else {
    console.log(item);
    return false;
  }
});
```

## 如何理解面向对象，以及如何理解函数式编程

## 浏览器的渲染过程

1. DNS 的查询(也就是根据域名去找对应的 ip 地址)
2. TCP 的连接(连接建立、数据传送以及连接释放)
3. HTTP 请求即响应
4. 服务端响应
5. 客户端渲染

渲染过程如下：

1. 解析 html 生成 dom 树
2. 解析 css 生成 cssom 树
3. 将 dom 树和 cssom 树规则合并在一起生成渲染树
4. 遍历渲染树开始布局，计算每一个节点的位置信息等
5. 将渲染树每个节点绘制到屏幕

## 浏览器的缓存机制

浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 抱文的缓存标识进行的，HTTP 抱文分为两种：

1. HTTP 请求(Request)抱文
2. HTTP 响应(Response)抱文

浏览器与服务器通信的方式为应答模式，即为：[浏览器发起 HTTP 请求 – 服务器响应该](/posts/internet/TCP的3次握手)请求，那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中

1. 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
2. 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

缓存分为强制缓存和协商缓存

* 强制缓存

  * HTTP 响应报文中的 expires--`expires: Wed, 21 Oct 2020 03:25:41 GMT`，这个是一个绝对时间，在指定的时间前请求缓存生效
  * HTTP 响应报文中的 Cache-Control--`cache-control: max-age=600`，这是一个相对值，单位 s，也就是 600s 之内再次请求会直接使用缓存，强制缓存生效
    > 在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control 相比于 expires 是更好的选择，所以同时存在时，只有 Cache-Control 生效

  强制缓存的返回状态码为： 200

  但是看返回值中的 size 栏中有`from memory cache`和`from disk cache`：分别是内存中的缓存和硬盘中的缓存，浏览器对与两者的读取顺序是： memory -> disk

  1. 内存缓存：快速读取（直接写入进程的内存中，方便下次使用和快速读取）和时效性（也就是一旦关闭进程关闭，内存就会清空）

  2. 直接将缓存写入硬盘文件中，读取缓存需要对硬盘文件进行 I/O 操作，读取是复杂的，速度也是比内存慢的

* 协商缓存(协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程)
  * 协商缓存生效，返回 304
  * 协商缓存失效，返回 200 和请求结果结果

协商缓存的表示在响应的报文中为：`Last-Modified / If-Modified-Since` 和 `Etag / If-None-Match`， 其中 `Etag / If-None-Match` > `Last-Modified / If-Modified-Since`

* 也就是说： 强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存

![图解](../../.vuepress/public/img/cache.png)

## 浏览器的垃圾回收机制与内存泄漏

浏览器对 js 具有自动垃圾回收机制(GC: Garbage COllecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存，其原理：_垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存_。但是这个过程不是实时的，因为其开销比较大并且 GC 时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。

两种实现方式：`标记清除`和`引用计数`。引用计数不太常用，标记清除较为常用。

### 1. 标记清除

js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，变量“进入环境”，被标记，离开环境时，被回收

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包），而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
到目前为止，IE9+、Firefox、Opera、Chrome、Safari 的 js 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

### 2. 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。

```js
function test() {
  var a = {}; //a的引用次数为0
  var b = a; //a的引用次数加1，为1
  var c = a; //a的引用次数再加1，为2
  var b = {}; //a的引用次数减1，为1
}
```

使用这种方法看起来好像很好理解，但当遇到循环引用的时候就很难受了

```js
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.e = element;
element.o = myObject;
```

```js
window.onload = function outerFunction() {
  var obj = document.getElementById("element");
  obj.onclick = function innerFunction() {};
};
```

第二个例子：obj 引用了 `document.getElementById('element')`，onclick 方法会引用外部环境中的变量，自然也包括 obj，这种隐蔽的循环引用很难发现的

遇到这样的情况我们需要手动去解除

```js
myObject.element = null;
element.o = null;

window.onload = function outerFunction() {
  var obj = document.getElementById("element");
  obj.onclick = function innerFunction() {};
  obj = null;
};
```

在 `IE8-`格外需要注意这些事情，不过现在我们开发需要兼容 `IE8-`的情况正在一步步减少

### 内存管理

1. 何时触发垃圾回收？

垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6 的垃圾回收是根据内存分配量运行的，当环境中存在 256 个变量、4096 个对象、64k 的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。

微软在 IE7 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和 IE6 相同，如果垃圾回收器回收的内存分配量低于程序占用内存的 15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，如果回收的内存高于 85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作职能了很多

2. 合理的 GC 方案

* 基本方案
  Javascript 引擎基础 GC 方案是（simple GC）：mark and sweep（标记清除），即：

  1. 遍历所有可访问的对象。
  2. 回收已不可访问的对象。

* GC 缺陷
  和其他语言一样，javascript 的 GC 策略也无法避免一个问题：GC 时，停止响应其他操作，这是为了安全考虑。而 Javascript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应。

* GC 优化策略

  1. 分代回收：区分“临时”与“持久”对象，多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需要遍历的对象
  2. 增量 GC：增加回收次数，牺牲的是中断次数

## 防抖、节流

1. 防抖：

* 在时间出发n秒后再执行回调，如果在这n秒以内又被触发了，则重新计时
* 适用场景：
  * 按钮的提交：防止重复提交
  * 搜索框检索，防止频繁调用接口影响体验和对服务器造成压力

```js
const debounce = (func, wait) => {
  let timeout
  return function () {
    const context = this
    const args = arguments
    clearTimeout(timeout)
    timeout = setTimeout(() => {
      func.apply(context, args)
    }, wait)
  }
}

const debounce = (func, wait, immediate) => {
  let timeout
  return function () {
    const context = this
    const args = arguments
    if (immediate) {
      const callNow = !timeout
      timeout = setTimeout (() => {
        timeout = null
      })
      if (callNow) fn.apply(this, args)
    } else {
      timeout = setTimeout(() => {
        func.apply(context, args)
      }, wait)
    }
  }
}
```

2. 节流：

* 规定在一个时间内，只能触发一次函数，如果这个时间内多次触发，只生效一次
* 适用场景：
  * 拖拽场景：防止dom大量的重拍影响性能
  * 缩放场景：频繁触发resize，性能

```js
const throttle = (fn, wait) => {
  let timeout
  return function () {
    const context = this
    const args = arguments
    if (!timeout) {
      timeout = setTimeout(() => {
        timeout = null
        fn.apply(context, args)
      })
    }
  }
}
```

## 闭包

1. 什么是闭包

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，既形成闭包

2. 闭包原理

函数执行分成两个阶段(预编译阶段和执行阶段)。

* 在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。
* 执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量

利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。

3. 优点

* 3.1. 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期在内存中，可以使用
* 3.2. 避免变量全局污染
* 3.3. 把变量储存在独立的作用域，作为私有成员存在

4. 缺点

* 4.1. 内存泄漏
* 4.2. 对速度的影响，内部的层级决定了引用的外部变量在查找时经过的作用链长度
* 4.3. 可能获取意外值

5. 使用场景

* 5.1 模块封装

```js
var fn = (function () {
  var foo = 0
  function func () {}
  fn.prototype.bar = function () {
    return foo
  }
  return func
})
```

* 5.2 循环中使用

```js
for (var i = 0;  i < 3; i++) {
  (function (j) {
    setTimeout(() => {
      console.log(j)
    }, 0)
  })(i)
}
```

## 写一个mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b,...,a+nb 的时间，执行一次fn，然后写一个 myClear，停止上面的 mySetInterVal

::: details 查看演示代码
<<< @/docs/.vuepress/public/demo/js/mySetInterVal.js
:::

## 实现 add(1)(2)(3)

```js
/**
 * add(1)(2)(3)
 */

const add = function()  {
  if(!add.result) add.result = 0
  add.result = [...arguments].reduce((sum,item) => sum + item, add.result)
  return add
}

const s = add(1, 2)(3)(4,5).result
console.log(s)
```

## 实现链式调用

不管是原来的jq还是现在的一些数组，链式调用的核心都是`return this`

## 类数组和数组的区别，dom 的类数组如何转换成数组

区别：

1. 数组有索引
2. 数组有长度，对象没有

什么是类数组

1. 拥有length属性，且索引为非负整数
2. 不具有数组的方法

eg:

```js
let e = {  
  length: 3,  
  "0": 1,  
  "1": 'sss',  
  "2": 'rerer'
}
for (var i = 0; i < e.length; i++) {  
    console.log(e[i]);
}
e instanceof Array  // false
e instanceof Object // true
```

如何判断快速判断数组和类数组

Object.prototype.toStrong.call()

[object Array]
[object Object]

```js
function isArrayLike(o) {     
  if (
      o && // o is not null, undefined, etc.          
      typeof o === 'object' && // o is an object          
      isFinite(o.length) && // o.length is a finite number          
      o.length >= 0 && // o.length is non-negative          
      o.length===Math.floor(o.length) &&  // o.length is an integer          
      o.length < 4294967296 // o.length < 2^32    
    )                    
    return true; // Then o is array-like  else          
    return false;                       // Otherwise it is not
}
```

如何转化

```js
let e = { 
  length: 3,  
  "0": 1,  
  "1": 'sss',  
  "2": 'rerer'
}

// 1. array.from
console.log(Array.from(e))
// 2. slice
console.log([].slice.call(e))
// 3. dom时候
console.log(...e)
```

## 介绍下 promise 的特性、优缺点，内部是如何实现的，动手实现 Promise

1. Promise特性

* 1. Promise有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)
* 2. Promise对象接受一个回调函数作为参数, 该回调函数接受两个参数，分别是成功时的回调resolve和失败时的回调reject；另外resolve的参数除了正常值以外， 还可能是一个Promise对象的实例；reject的参数通常是一个Error对象的实例。
* 3. then方法返回一个新的Promise实例，并接收两个参数onResolved(fulfilled状态的回调)；onRejected(rejected状态的回调，该参数可选)
* 4. finally方法不管Promise状态如何都会执行，该方法的回调函数不接受任何参数
* 5. Promise.all()方法将多个Promise实例，包装成一个新的Promise实例，该方法接受一个由Promise对象组成的数组作为参数(Promise.all()方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例)，注意参数中只要有一个实例触发catch方法，都会触发Promise.all()方法返回的新的实例的catch方法，如果参数中的某个实例本身调用了catch方法，将不会触发Promise.all()方法返回的新实例的catch方法
* 6. Promise.race()方法的参数与Promise.all方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给Promise.race()方法，并将返回值作为Promise.race()方法产生的Promise实例的返回值

2. Promise优点

* 1. 统一异步 API
  * Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。
* 2. 和事件对比
  * 和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。 Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。
* 3. 和回调对比
  * 解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。
* 4. Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如 Array.prototype.map() ）。

3. Promise缺点

* 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
* 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
* 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
* Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。

4. 如何实现

::: details 查看演示代码
<<< @/docs/.vuepress/public/demo/js/promise.js
:::

## 手写发布订阅（手写一个eventBus）

::: details 查看演示代码
<<< @/docs/.vuepress/public/demo/js/eventbus.js
:::

## 手写数组转树

::: details 查看演示代码
<<< @/docs/.vuepress/public/demo/js/arrToTree.js
:::

## 手写实现 Array.flat()

[详情](./#_7-数组实例的-flat-flatmap)

## 大数计算如何实现

```js
const a = 111111111111111111n
const b = 232222222222222222n
console.log(a+b)
```

## 什么是深拷贝，和浅拷贝有什么区别，动手实现一个深拷贝

1. 深拷贝：就是对对象以及对象的所有子对象进行复制

2. 浅拷贝：只复制一层对象的属性，并不包括对象里面的为引用类型的属性值，因此修改拷贝后的属性都是引用类型的就会影响原对象

::: details 查看演示代码
<<< @/docs/.vuepress/public/demo/js/deepclone.js
:::

## 实现一个方法判断 html 中的标签是否闭合

```js
/^<([a-zA-Z]+)>[\s\S]*?</\1>$/
```

## 箭头函数和普通函数的区别

1. 箭头函数不能绑定arguments，而是使用`rest`的`...`解决方案
2. 箭头函数是匿名函数，不能作为构造函数不能使用new
3. 箭头函数没有原型属性
4. 箭头函数不能绑定this，会将离自己最近的一个普通函数的this作为自己的this
5. call、apply、bing都无法改变箭头函数的this指向

## es5 实现 isInteger

```js
Number.isInteger = function (val) {
  // ~: 取相反数再减1
  return typeof val === "number" && ~~val === val;
};
```

## 手写 dom 操作，翻转 li 标签，如何处理更优

```html
/*
 *有下边这样的dom结构，现在可以获取到ul，要求翻转里边li标签，如何处理更优
 */
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
```

## 是否了解 glob，glob 是如何处理文件的，业界是否还有其它解决方案

## 随便打开一个网页，用 JavaScript 打印所有以 s 和 h 开头的标签，并计算出标签的种类

```js
const allTags = [...document.querySelectorAll('*')].reduce((arr, item) => {
  if (!arr.includes(item.localName)){
    arr.push(item.localName)
  }
  return arr
}, [])

console.log('所有品类------->', allTags.length)
console.log('s/h标签名------->', allTags.filter(item => item[0] === 's' || item[0] === 'h'))
```

## 1000*1000 的画布，上面有飞机、子弹，如何划分区域能够更有效的做碰撞检测，类似划分区域大小与碰撞检测效率的算法，说一下大致的思路

::: details 查看演示代码
<<< @/docs/.vuepress/public/demo/js/impact-checking.js
:::

扩展：在三维里面两个物体的碰撞，其实和上面的作法是一样，就不写了

延展思维：两个矩阵点乘

::: details 查看演示代码
<<< @/docs/.vuepress/public/demo/js/matrix-multi.js
:::

## 移动设备Android与 iOS 的软键盘弹出的处理方式有什么不同

1. Android：入框获取焦点，键盘弹起，页面（webview）高度会发生改变，高度为可视区高度（原高度减去软键盘高度），除了因为页面内容被撑开可以产生滚动，webview本身不能滚动。

2. IOS：在 IOS 上，输入框（input、textarea 或 富文本）获取焦点，键盘弹起，页面（webview）并没有被压缩，或者说高度（height）没有改变，只是页面（webview）整体往上滚了，且最大滚动高度（scrollTop）为软键盘高度。

## iPhone 里面 Safari 上如果一个输入框 fixed 绝对定位在底部，当软键盘弹出的时候会有什么问题，如何解决

flex + scrollIntoView

## 给定一个数组，按找到每个元素右侧第一个比它大的数字，没有的话返回-1 规则返回一个数组

```js
/*
 * 示例：
 * 给定数组：[2,6,3,8,10,9]
 * 返回数组：[6,8,8,10,-1,-1]
 */
const func = arr => arr.reduce((newArr, item, index) => {
  newArr[index] = arr.slice(index).filter(f => f > item)?.[0] || -1
  return newArr
}, [])

console.log(func([2,6,3,8,10,9]))
```

## 说一说 promise，有几个状态，通过 catch 捕获到 reject 之后，在 catch 后面还能继续执行 then 方法嘛，如果能执行执行的是第几个回调函数

1. 状态： pending、resolved(fulfilled)、rejected

2. 可以， 如果没有返回新的promise这执行第2个回调，如果返回的了，按照新的返回值执行

## 如何实现按需加载

import

## 讲一下 import 的原理，与 require 有什么不同

区别：

1. import是es6的产物；require是commonJS的产物
2. 导出方法的区别（umd的使用的好处）、写法上的区别，import必须在头部
3. 都是异步加载；import是解构过程，编译时候生效执行；require是赋值过程，在运行时执行

## 是否用过 restful 接口，和其他风格的有什么区别

## 手写用 ES6proxy 如何实现 arr[-1] 的访问

## 说一下 get、post、put 的区别

|method|get|post|put|delete|patch（2010年新加，对put的补充）|
|-|-|-|-|-|-|
|作用|信息获取|创建数据|创建/完整更新数据|删除数据|更新部分数据|
|幂等|是|否|是|是|否|
|常用场景|select操作|create操作|update操作|delete操作|对已知数据的部分更新|

> 幂等：一个操作、方法或者服务，其任意多次执行所产生的影响均与一次执行的影响相同。

## 说一下对面向对象的理解，面向对象有什么好处

万物皆对象，比较方便的能够把一类问题用代码简单的说清楚

## 类设计：使用面相对象设计一个停车场管理系

::: details 查看演示代码
<<< @/docs/.vuepress/public/demo/js/parkcar.js
:::

## 手写代码实现kuai-shou-front-end=>KuaiShouFrontEnd

```js
const str = 'kuai-shou-front-end'
// NOTE: 横线转驼峰
const lineToW = str => str.replace(/(-\w)/g, $1 => $1[1].toUpperCase())
// NOTE: 驼峰转横线
const wToLine = str => str.replace(/[A-Z]/g, $1 => `-${$1.toLowerCase()}`)
console.log(wToLine(lineToW(str)))
```

## 用尽量短的代码实现一个 arrary 的链式操作，将数组中的大于 10 的值进行一个累加

```js
const sum10 = arr => arr.reduce((sum, item) => item <= 10 ? (sum + +item) : sum, 0)
console.log(sum10([1,2,3,4,5,11])) // 15
```

## ES6对象面试题整理

### Object.keys(a)、Object.getOwnPropertyNames(a)、Reflect.ownKeys(a)以及for in、Object.getOwnPropertyDescriptors的区别

```js
console.log(Oject.keys(c)) // 获取对象上正常的属性, 不包括Symbol属性，但是不包括enumerable属性
console.log(Object.getOwnPropertyNames(c)) // 还可以获取不可迭代属性，既enumerable无false的属性
console.log(Reflect.ownKeys(c)) // 处理可以获取不可迭代属性，还可以获取Symbol属性

for (let a in c) { // 可以获取原型属性，但是不可获取不可迭代和Symbol对象。但是无法获取不可迭代属性和Symbol属性
  console.log(a)
}
```

可以使用`Object.getOwnPropertySymbols(c)`获取对象上所有的Symbols属性。

Object.getOwnPropertyDescriptors是获取一个对象的所有的属性的描述符。

### 在ES6中，如何实现私有属性

使用Symbol，利用Symbol的唯一性，只要这个不对外暴露Symbol的索引，那么Symbol就不会被访问带

在es next里面提供了private属性，使用#表示

### Object.is有什么用，和===有什么区别？

`Object.is`可以判断NaN等于自身，而`+0`不等于`-0`

```js
+0 === -0 //true
NaN === NaN // false
Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

### Object.assign的参数可以不是对象吗？

可以，参数不对，会尝试将其转换为对象，但是如果是null和undefined无法转换为对象，所以它们作为参数会报错。
如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。
首先，这些参数都会转成对象，如果无法转成对象，就会跳过。
这意味着，如果undefined和null不在首参数，就不会报错。
所以，很多时候为了安全我们会这样写：

```js
var o = Object.assign({}, a, b)
```

### Object.assign可以拷贝原型链上的属性吗？不可枚举的呢？Symbol呢？

`Object.assign`只可以拷贝源对象自身的属性，不拷贝继承属性，也不拷贝不可枚举属性，但是可以拷贝Symbol属性。

### Object.assign可以用在数组上吗？

是可以的，数组会被当做对象

```js
var c = Object([1,2,3,4,5], [9,8,7]) // [9,8,7,4,5]
```

### 下面代码运行结果是？

```js
const source = {
  get foo() { return 1 }
};
const target = {};
var r = Object.assign(target, source);
console.log(r)
```

结果是`{foo: 1}`,Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。

### Object.assign能拷贝get和set属性吗，Symbol和enumerable为false的属性呢？

不能，这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。
所以，如果是get方法，拷贝的内容是一个get方法返回的值，如果是set方法，拷贝的值则是undefined。
属性名会被拷贝。Symbol是可以拷贝的，但是enumerablle为false的不行。

### 如果想要拷贝一个对象，并且还想合并其get和set之类所有的属性怎么做？

可以使用`Object.getOwnPropertyDescriptors()`方法配合`Object.defineProperties()`方法，就可以实现拷贝get和set方法。

```js
Object.defineProperties({}, Object.getOwnPropertyDescriptors(o));
```

同理，Object.assign也不能复制enumerable为false的属性，但是defineProperties可以。

注意，这里如果只是希望单纯的拷贝，而不是类似`Object.assign`带有合并的功能，可以使用`Object.create`。
使用`Object.create`的有点在于可以将第一个参数设置为对象的原型，这样拷贝的对象也和源对象具有同样的原型链。

```js
Object.create(
  Object.getPrototypeOf(o),
  Object.getOwnPropertyDescriptors(o)
);
```

### 如何将一个对象设置为另一个对象的原型？

在以前，我们可以通过__proto__这种方法来指定一个对象是另一个对象的原型，但是这种用法并不是js的规范，只是一个内部属性。
虽然大部分浏览器和nodejs引擎实现了这种写法，当一般不推荐这样用。
在ES6中新加了setPrototypeOf，可以直接实现这个需求。

另外，我们还可以通过Reflect来设置. `Reflect.setPrototypeOf(obj, newProto)`

### 如何使用for of遍历对象，能遍历到原型链上的对象吗？能遍历enumerable为false的属性吗？能遍历Symbol吗？

对象本地是不可迭代的，但是可以使用Object.keys、Object.values、Object.entries获取对象的属性和值组成的数组。
他们都不包括enumerable为false和Symbol()的属性。

注意：数组也有keys、values、entries三个方法。但是数组可以直接for of遍历。Set也是这样。

### Map与Object的区别是？

Map和Object都是键值对的集合（Hash结构），但是Map支持各种类型的值作为键。包括对象。
Map判断键是否相同，采用的是判断是地址是否是同一个地址，这样的优点是对别人的库进行扩展的时候，
如果采用对象作为键，则不会对别人的库进行污染。

当然：一般这种情况要对象的扩展，我们可以用Symbol

Map还可以使用for of对齐进行遍历，而Object不可以。

### Symbol的描述有什么用

在Symbol作为一个对象的函数的key的时候，这个函数的name属性返回的是Symbol值的描述

```js
var key = Symbol('description')
var ob = {
  [key] () {}
}
console.log(ob[key].name) // [description]
console.log(key.toString()) // Symbol(desription)

```

### 可枚举属性enumerable被设置为false，会影响那些情况

1. 无法被`for...in`循环遍历
2. 无法被`Object.keys`获取属性
3. 无法被JSON.stringify序列化
4. 无法被`Object.assign`克隆
  
ES6规定，Class的原型的方法都是不可枚举的。

### `super`只能用到class的constructor中吗

不是，super还可以用到直接对象的方法里面，用来指对象。

super也可以在class的static方法中调用父类的static方法

```js
const proto = {
  foo: 'hello'
};
const obj = {
  foo: 'world',
  find() {
    return super.foo;
  }
};
Object.setPrototypeOf(obj, proto);
obj.find() // "hello"
```

注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。

JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。

### 一个对象被设置了Object.preventExtensions后，还可以向这个对象的原型添加属性吗

可以的，Object.preventExtensions只阻止向这个对象添加属性，不会阻止向原型添加。

一旦使其不可扩展，就无法再对象进行扩展。

在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常。

在 ES2015 中，非对象参数将被视为一个不可扩展的普通对象，因此会被直接返回。

使用`Reflect.preventExtensions(target)`添加不是一个对象类型则也会报错。

<gitask />

