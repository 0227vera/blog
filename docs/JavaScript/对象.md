# 对象
在js中，所有其他对象都继承自Object对象，也就是说其他的我们所定义的对象都是Object的实例Object对象原声的方法分为两类：本事的方法和实例的方法，而说到对象，肯定也得说说面向对象，对ES5的面向对象，我自己个人并不认为它是面向对象，原因是：我觉得ES5的上面写法没有统一，你有你的写法，我有我的写法，关键是还没有错，都是对的

## 对象
  * 本身的方法
    - Object.print = function (o) { console.log(o); }; 这种直接加在对象上的就是对象本身的方法,不可以被实例的对象调用
  * 实例方法
    - 所谓实例方法就是定义在对象Object.prototype上的方法，它可以被Object实例直接使用
    ```js
    Object.print1 = function () {
      console.log(00)
    }
     Object.print = function () {
      console.log(11)
    }
    Object.prototype.print = function () {
      console.log(22)
    }
    let obj = new Object()
    obj.print() // 22
    obj.print1() // Error
    ```
  * 构造函数
  > 值得注意的是，通过let obj = new Object()的写法生成新对象，与字面量的写法let obj = {}是等价的。或者说，后者只是前者的一种简便写法。
  ```js
    let o1 = {a: 1};
    let o2 = new Object(o1);
    o1 === o2 // true
    let obj = new Object(123);
    obj instanceof Number // true
    // Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。
  ```
  * 静态方法
    * Object.keys() (在平常开发中用的还是比较多的)
    ```js
      // 需求打开一个地址参数是
      let obj = {
        name: 'salvatore',
        id: 'adfhlw452345lahfa1234lha0per8f7',
        type: 'new',
        area: 'ss'
      }
      window.open(`/?name=${obj.name}&id=${obj.id}&type=${obj.type}&area=${obj.area}`) // 这种也可以，但是对于维护起来不是很好，如果加一个字段还要改两个地方，这个时候用Object.keys()
      let path = ''
      Object.keys(obj).forEach(item => {
        path = path ? path += `&${item}=${obj[item]}` : path += `/?${item}=${obj[item]}`
      })
      console.log(path) //---> /?name=salvatore&id=adfhlw452345lahfa1234lha0per8f7&type=new&area=ss
    ```

    * Object.getOwnPropertyNames()----这哥们通常来讲会比Object.keys()多一个length，我一般都是用Object.keys()遍历对象属性
  
  * 其他方法
  1. 对象属性模型的相关方法
      * Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。
      * Object.defineProperty()：通过描述对象，定义某个属性。
      * Object.defineProperties()：通过描述对象，定义多个属性。
  2. 控制对象状态的方法
      * Object.preventExtensions()：防止对象扩展。
      * Object.isExtensible()：判断对象是否可扩展。
      * Object.seal()：禁止对象配置。
      * Object.isSealed()：判断一个对象是否可配置。
      * Object.freeze()：冻结一个对象。
      * Object.isFrozen()：判断一个对象是否被冻结。
  3. 原型链相关方法
      * Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。
      * Object.getPrototypeOf()：获取对象的Prototype对象。
  ```js
  // 以上这些方法我就用过Object.defineProperty()，其他的我都还没有用过，但Object.freeze()这样的还是用听过的看过的，没有过用过的
  // Object.defineProperty()这哥们是做数据双向绑定的基本原理上，上代码
  let input = document.getElementById('input')
  let span = document.getElementById('span')
  let obj = {}
  Object.defineProperty(obj, 'text', {
    set(val){
      input.value = val
      span.innerHTML = val
    }
  })
  input.addEventListener('keyup',(event) => {
    obj.text = event.target.value
  })
  ```
  ```html
    <input id="input">
    <span id="span"></span>
  ```
 * Object的实例方法
    * Object.prototype.valueOf()：返回当前对象对应的值。
    * Object.prototype.toString()：返回当前对象对应的字符串形式。
    * Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。
    * Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。
    * Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。
    * Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。
  * 说两个我用的比较多的属性直接上代码
    ```js
    function getType (type) {
      return Object.prototype.toString.call(type).match(/\[object, (.*?)\]/)[1].toLowerCase()
    }
    type({}); // "object"
    type([]); // "array"
    type(5); // "number"
    type(null); // "null"
    type(); // "undefined"
    type(/abcd/); // "regex"
    type(new Date()); // "date"

    let typeFixed = {}
    const arr = ['Null', 'Undefined', 'Object', 'Array', 'String', 'Number', 'Boolean', 'Function', 'RegExp']
    arr.forEach(item => {
      typeFixed[`is${item}`] = function (type) {
        return getType(type) === item.toLowerCase()
      }
    })

    typeFixed.isObject({}) // true
    type.isNumber(NaN) // true
    type.isRegExp(/abc/) // true
    ```
    ```js
    let obj = {
      p: 123
    };
    obj.hasOwnProperty('p') // true
    obj.hasOwnProperty('toString') // false
    // Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。
    ```
## 面向对象
<back-to-top />