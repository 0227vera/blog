# 对象
在js中，所有其他对象都继承自Object对象，也就是说其他的我们所定义的对象都是Object的实例Object对象原声的方法分为两类：本事的方法和实例的方法，而说到对象，肯定也得说说面向对象，对ES5的面向对象，我自己个人并不认为它是面向对象，原因是：我觉得ES5的上面写法没有统一，你有你的写法，我有我的写法，关键是还没有错，都是对的

## 对象
  * 本身的方法
    - Object.print = function (o) { console.log(o); }; 这种直接加在对象上的就是对象本身的方法,不可以被实例的对象调用
  * 实例方法
    - 所谓实例方法就是定义在对象Object.prototype上的方法，它可以被Object实例直接使用
    ```js
    Object.print1 = function () {
      console.log(00)
    }
     Object.print = function () {
      console.log(11)
    }
    Object.prototype.print = function () {
      console.log(22)
    }
    let obj = new Object()
    obj.print() // 22
    obj.print1() // Error
    ```
  * 构造函数
  > 值得注意的是，通过let obj = new Object()的写法生成新对象，与字面量的写法let obj = {}是等价的。或者说，后者只是前者的一种简便写法。
  ```js
    let o1 = {a: 1};
    let o2 = new Object(o1);
    o1 === o2 // true
    let obj = new Object(123);
    obj instanceof Number // true
    // Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。
  ```
  * 静态方法
    * Object.keys() (在平常开发中用的还是比较多的)
    ```js
      // 需求打开一个地址参数是
      let obj = {
        name: 'salvatore',
        id: 'adfhlw452345lahfa1234lha0per8f7',
        type: 'new',
        area: 'ss'
      }
      window.open(`/?name=${obj.name}&id=${obj.id}&type=${obj.type}&area=${obj.area}`) // 这种也可以，但是对于维护起来不是很好，如果加一个字段还要改两个地方，这个时候用Object.keys()
      let path = ''
      Object.keys(obj).forEach(item => {
        path += (path ? `&` : `/?`) + `${item}=${obj[item]}`
      })
      console.log(path) //---> /?name=salvatore&id=adfhlw452345lahfa1234lha0per8f7&type=new&area=ss
    ```

    * Object.getOwnPropertyNames()----这哥们通常来讲会比Object.keys()多一个length，我一般都是用Object.keys()遍历对象属性
  
  * 其他方法
  1. 对象属性模型的相关方法
      * Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。
      * Object.defineProperty()：通过描述对象，定义某个属性。
      * Object.defineProperties()：通过描述对象，定义多个属性。
  2. 控制对象状态的方法
      * Object.preventExtensions()：防止对象扩展。
      * Object.isExtensible()：判断对象是否可扩展。
      * Object.seal()：禁止对象配置。
      * Object.isSealed()：判断一个对象是否可配置。
      * Object.freeze()：冻结一个对象。
      * Object.isFrozen()：判断一个对象是否被冻结。
  3. 原型链相关方法
      * Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。
      * Object.getPrototypeOf()：获取对象的Prototype对象。
  ```js
  // 以上这些方法我就用过Object.defineProperty()，其他的我都还没有用过，但Object.freeze()这样的还是用听过的看过的，没有过用过的
  // Object.defineProperty()这哥们是做数据双向绑定的基本原理上，上代码
  let input = document.getElementById('input')
  let span = document.getElementById('span')
  let obj = {}
  Object.defineProperty(obj, 'text', {
    set(val){
      input.value = val
      span.innerHTML = val
    }
  })
  input.addEventListener('keyup',(event) => {
    obj.text = event.target.value
  })
  ```
  ```html
    <input id="input">
    <span id="span"></span>
  ```
 * Object的实例方法
    * Object.prototype.valueOf()：返回当前对象对应的值。
    * Object.prototype.toString()：返回当前对象对应的字符串形式。
    * Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。
    * Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。
    * Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。
    * Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。
  * 说两个我用的比较多的属性直接上代码
    ```js
    function getType (type) {
      return Object.prototype.toString.call(type).match(/\[object, (.*?)\]/)[1].toLowerCase()
    }
    type({}); // "object"
    type([]); // "array"
    type(5); // "number"
    type(null); // "null"
    type(); // "undefined"
    type(/abcd/); // "regex"
    type(new Date()); // "date"

    let typeFixed = {}
    const arr = ['Null', 'Undefined', 'Object', 'Array', 'String', 'Number', 'Boolean', 'Function', 'RegExp']
    arr.forEach(item => {
      typeFixed[`is${item}`] = function (type) {
        return getType(type) === item.toLowerCase()
      }
    })

    typeFixed.isObject({}) // true
    type.isNumber(NaN) // true
    type.isRegExp(/abc/) // true
    ```
    ```js
    let obj = {
      p: 123
    };
    obj.hasOwnProperty('p') // true
    obj.hasOwnProperty('toString') // false
    // Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。
    ```
## 面向对象
  * new
    * 对象是什么？
      1. 对象是单个事物的抽象
      2. 对象是一个容器，封装了属性（property）和方法（method）
          - 属性是对象的状态，方法是对象的行为（完成某种任务）
    构造函数
      * 对于JS来讲，对象体系是基于构造函数（constructor）和原型链（prototype）
    ```js
    let Salvatore = function() {
      this.status = '心态永远年轻'
    }
    ```
    从上可以看出，构造韩式就是一个普通函数，但是有自己的特征和用法，Salvatore就是构造函数，为了与普通函数区别，构造函数名字的第一个字母通常大写。构造函数的特点有两个。
      1. 函数体内部的this关键字，代表了所要生成的对象实例（也可以说是，谁来new它他就是指向谁，关于this的问题马上就会细细了解的）
      2. 生成对象的时候，必须使用new命令
    * 如何使用new
    ```js
    let Salvatore = function() {
      this.status = '心态永远年轻'
    }
    let xuanliao = new Salvatore()
    xuanliao.status // '心态永远年轻'
    // 再对象内部使用局部的严格模式，如果完了使用new命令直接调用回报错
    function Salvatore (name,age){
      'use strict'
      this._name = name
      this._age = age
    }
    Salvatore() // error
    // 或者利用new的target判断是否是new的对象
    function Salvatore (name,age) {
      if (new.target === Salvatore) {
        return new Error('请使用new命令声明对象！')
      }
      this._name = name
      this._age = age
    }
    // 上面的方法是给出报错信息，让开发者能够察觉，一下还有一种办法解决new的问题
    function Salvatore (name,age) {
      if (!(this instanceof Salvatore)) { // 在用! || 这样的运算符的时候一定看好范围，是否需要括号
        return new Salvatore(name,age)
      }
      this._name = name
      this._age = age
    }
    Salvatore('xuanliao', 25) // 可以正常使用
    new Salvatore('xuanliao', 25) // 也能够使用
    ```
    * new命令的原理
      * 使用new命令时，4步走
        1. 创建一个空对象，作为将要返回的对象实例。
        2. 将这个空对象的原型，指向构造函数的prototype属性。
        3. 将这个空对象赋值给函数内部的this关键字。
        4. 开始执行构造函数内部的代码。
        <!-- todo: 用代码实现 -->
        ```js
          function _new(constructor, params) {
            let args = [].slice.call(arguments) // 将对象转化成数组
            let constructor = args.shift() // 将构造函数取出 shift回改变数组
            let context = Object.create(constructor.prototype) // 创造一个空对象，继承构造函数的prototype的属性
            let result = constructor.apply(context, args)
            return (typyof result === 'object' && result != null) ? result : context
          }
          let actore = _new(Salvatore,'xuanliao',25)
        ```
        - 对于四步走我的理解是：先生成一个空对象，然后把关于所有this的操作，属性，方法，全部挂在空对象上面，也就是把构造函数的this指向空对象
        - 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。
        ```js
            let Salvatore = function () {
            this.price = 1000;
            return 1000;
          };
          (new Salvatore()) === 1000 // false
          // 想起分装vue中的Axios中的return new Promise()
        ```
    * 利用Object.create()创建实例对象
    ```js
    let sa = {
      name:'xuanliao',
      age:25,
      say: function () {
        console.log(`我叫${this.name},我今年${this.age}`)
      }
    }
    let salvatore = Object.create(sa)
    salvatore.say() // 我叫xuanliao,我今年25
    // 对象sa是salvatore的模板，后者继承了前者的属性和方法。
    ```
  * this
    - this的涵义
      * this在有些场景可以理解为“当前”的意思
      ```js
        let obj1 = {
          name: 'salvatore',
          say(){
            console.log(this.name)
          }
        }
        let obj2 = {
          name:'xuanliao'
        }
        obj2.say = obj1.say
        obj2.say() // xuanliao  // 此时say方法的this指向的是当前obj2这个对象
      ```
      ```js
      let obj1 = {
          name: 'salvatore',
          say(){
            console.log(this.name)
          }
      }
      let func = obj1.say
      func() // undefine this---->全局对象，但全局对象上面没有name的属性
      ```
      * 在JS中，万物皆对象，运行环境也是对象，所以函数都是在某个对象之中运行的，而this就是函数执行时所在的环境，如果只是这样的，是不会让你我觉得云里雾里的，主要是JS的运行环境是动态切换的，导致this的指向是动态的，不可以在刚开始的时候就确定this的指向，在ES6中有了箭头函数就好了，那样就会比较好理解了
    * 绑定this的方法
      * call，this，bind，这几个哥们不知道说什么，都是改变this的指针，说几个应用场景
      ```js
      <!-- call -->
      <!-- 判断type的类型，比typeof,instanceof更精确 -->
      Object.prototype.toString.call(type).match(/\[object (.*?)\]/)[1].toLowerCase()
      <!-- js实现简易版forEach -->
      Array.prototype._forEach = function (a, b) {
        for (var i = 0; i < this.length; i++) {
          <!-- 把上下文指向传进来的b -->
          a.call(b, this[i], i, this) 
        }
      }
      var a = [1, 1, 2, 3, 3, 4, 5]
      a._forEach(function (item, index, arr) {
        console.log(index, '---->', item, arr)
        console.log(this)
      }, 33)

      ```
      ```js
      <!-- apply -->
      <!-- 找到arr里面的最大数 最小数同理 -->
      Math.max.apply(null,arr) 
      <!-- 利用Array.prototype.concat.apply([],arr) 多维数组降维 -->
      function down(arr){
        return isMulti(arr) ? down(Array.prototype.concat.apply([],arr)) : arr
      }
      function isMulti (arr){
        let result = false
        arr.forEach(item => {
          if(isArray(item)){
            result = true
          }
        })
        return result
      }
      function isArray(type){
        return Object.prototype.toString.call(type).match(/\[object (.*?)\]/)[1].toLowerCase() === 'array'
      }
      <!-- 利用apply将类数组对象转为数组 -->
      <!-- 非常典型的将arguments转化成数组方便使用 -->
      let args = Array.prototype.slice.apply(arguments) 


      ```
      * 用bind(绑定)比较少
      ```js
      let counter = {
        count: 0,
        inc(){
          this.count++
        }
      }
      let func = counter.inc.bind(counter)
      <!-- 如果不使用bind，在调用的时候func显而易见的this指向全局，使用bind之后不管在任何地方调用func，this都指向counter -->
      func()
      counter.count === 1
      <!-- bind也可以传入多个参数（锁定传参） -->
      function add (x, y) {
        return x * this.m + y * this.m
      }
      let obj = {
        n: 5,
        m: 5
      }
      let add2 = add.bing(obj, 5)
      add2(5) === 20
      <!-- 将add中的x锁定值为5，再次调用add2的时候只需要传y即可 -->
      <!-- bind与call连用 -->
      let push = Function.prototype.call.bind(Array.prototype.push)
      push([1,2,3,4],5)
      <!-- 把call的this指向Array.prototype.push,用同样的原理apply会好理解很多 -->
      let push = Function.prototypy.apply.bind(Array.prototype.push)
      push([1,2,3,4],[5])
      <!-- 两个的返回值一样，就是把push的第一个参数就是this，第二个参数就是要push进去的值 -->
      ```

  * 继承
    - 前面说了那么多关于函数,new,this等等，而在实际使用的使用过程中，继承才是在封装和复用中起到很到作用的一个点
      1. 先说一下构造函数的缺点吧

      所有的实例对象都可以通过声明构成函数，实例对象可以生成构造函数上的属性和方法，但是有一点就是，对于属性还好说，可能会改变，但对于方法来讲一般是不会修改，同一个构造函数的多个实例对象之间属性和方法都无法共享，这个就很浪费资源了，解决方案就是使用原型对象（prototype）

      2. prototype属性的作用(prototype是一个对象object)

      对于普通函数来讲一本上是没有用的但对于构造函数来讲生成实例的时候,该属性会自动成为实例对象的原型
      ```js
      function Func(name, age) {
        this.name = name
        this.age = age
        this.sayHello = function () {
          console.log(`i am ${this.name},${this.age} years old`)
        }
      }
      let func = new Func('liaoxuan', 25)
      func.sayHello()
      <!-- 如果有多个Func的实例,此时如果我想修改sayHello方法,只能一个一个让实例去修改,显然这是不不好的,对属性也是一样的咯,所以再构造函数里面要分清楚常量和变量(可能会修改的) -->
      function Func1(name, age) {
        this.name = name
        this.age = age
      }
      Func1.prototype.sayHello = function () {
        console.log(`i am ${this.name},${this.age} years old`)
      }
      let func1 = new Func1('xuanliao', 23)
      Func1.prototype.sayHello = function (){
        console.log(`修改一下----------->i am ${this.name},${this.age} years old`)
      }
      func1.sayHello()
      ```
      3.原型链

      在js中,所有对象都有自己的原型对象(prototype)

        1. 任何一个对象都可以充当其他对象的原型对象
        2. 由于原型对象也是对象,所有他也又有自己的原型对象,因此就有了原型链的说法(prototype chain)

      这样一层一层的往上找,总得有个头,这个头就是Object.prototype,也就是说所有对象都是继承了Object.prototype的属性,这就是所有对象都有valueOf和toString等的方法的原型,这些鬼方法都是从Object.prototype上面带过去的,那么Object.prototype这哥们的原型是什么呢?是null,null没有任何的属性和方法,也没有原型,所以原型链的尽头是null
      ```js
      Object.getPrototypeOf(Object.prototype)
      // null
      ```



  * Object对象的相关方法
  * 严格模式

<back-to-top />