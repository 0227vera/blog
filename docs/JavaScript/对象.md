# 对象
在js中，所有其他对象都继承自Object对象，也就是说其他的我们所定义的对象都是Object的实例Object对象原声的方法分为两类：本事的方法和实例的方法，而说到对象，肯定也得说说面向对象，对ES5的面向对象，我自己个人并不认为它是面向对象，原因是：我觉得ES5的上面写法没有统一，你有你的写法，我有我的写法，关键是还没有错，都是对的

## 对象
  * 本身的方法
    - Object.print = function (o) { console.log(o); }; 这种直接加在对象上的就是对象本身的方法,不可以被实例的对象调用
  * 实例方法
    - 所谓实例方法就是定义在对象Object.prototype上的方法，它可以被Object实例直接使用
    ```js
    Object.print1 = function () {
      console.log(00)
    }
     Object.print = function () {
      console.log(11)
    }
    Object.prototype.print = function () {
      console.log(22)
    }
    let obj = new Object()
    obj.print() // 22
    obj.print1() // Error
    ```
  * 构造函数
  > 值得注意的是，通过let obj = new Object()的写法生成新对象，与字面量的写法let obj = {}是等价的。或者说，后者只是前者的一种简便写法。
  ```js
    let o1 = {a: 1};
    let o2 = new Object(o1);
    o1 === o2 // true
    let obj = new Object(123);
    obj instanceof Number // true
    // Object(value)与new Object(value)两者的语义是不同的，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value。
  ```
  * 静态方法
    * Object.keys() (在平常开发中用的还是比较多的)
    ```js
      // 需求打开一个地址参数是
      let obj = {
        name: 'salvatore',
        id: 'adfhlw452345lahfa1234lha0per8f7',
        type: 'new',
        area: 'ss'
      }
      window.open(`/?name=${obj.name}&id=${obj.id}&type=${obj.type}&area=${obj.area}`) // 这种也可以，但是对于维护起来不是很好，如果加一个字段还要改两个地方，这个时候用Object.keys()
      let path = ''
      Object.keys(obj).forEach(item => {
        path = path ? path += `&${item}=${obj[item]}` : path += `/?${item}=${obj[item]}`
      })
      console.log(path) //---> /?name=salvatore&id=adfhlw452345lahfa1234lha0per8f7&type=new&area=ss
    ```

    * Object.getOwnPropertyNames()----这哥们通常来讲会比Object.keys()多一个length，我一般都是用Object.keys()遍历对象属性
  
  * 其他方法
  1. 对象属性模型的相关方法
      * Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。
      * Object.defineProperty()：通过描述对象，定义某个属性。
      * Object.defineProperties()：通过描述对象，定义多个属性。
  2. 控制对象状态的方法
      * Object.preventExtensions()：防止对象扩展。
      * Object.isExtensible()：判断对象是否可扩展。
      * Object.seal()：禁止对象配置。
      * Object.isSealed()：判断一个对象是否可配置。
      * Object.freeze()：冻结一个对象。
      * Object.isFrozen()：判断一个对象是否被冻结。
  3. 原型链相关方法
      * Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。
      * Object.getPrototypeOf()：获取对象的Prototype对象。
  ```js
  // 以上这些方法我就用过Object.defineProperty()，其他的我都还没有用过，但Object.freeze()这样的还是用听过的看过的，没有过用过的
  // Object.defineProperty()这哥们是做数据双向绑定的基本原理上，上代码
  let input = document.getElementById('input')
  let span = document.getElementById('span')
  let obj = {}
  Object.defineProperty(obj, 'text', {
    set(val){
      input.value = val
      span.innerHTML = val
    }
  })
  input.addEventListener('keyup',(event) => {
    obj.text = event.target.value
  })
  ```
  ```html
    <input id="input">
    <span id="span"></span>
  ```
 * Object的实例方法
    * Object.prototype.valueOf()：返回当前对象对应的值。
    * Object.prototype.toString()：返回当前对象对应的字符串形式。
    * Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。
    * Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。
    * Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。
    * Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。
  * 说两个我用的比较多的属性直接上代码
    ```js
    function getType (type) {
      return Object.prototype.toString.call(type).match(/\[object, (.*?)\]/)[1].toLowerCase()
    }
    type({}); // "object"
    type([]); // "array"
    type(5); // "number"
    type(null); // "null"
    type(); // "undefined"
    type(/abcd/); // "regex"
    type(new Date()); // "date"

    let typeFixed = {}
    const arr = ['Null', 'Undefined', 'Object', 'Array', 'String', 'Number', 'Boolean', 'Function', 'RegExp']
    arr.forEach(item => {
      typeFixed[`is${item}`] = function (type) {
        return getType(type) === item.toLowerCase()
      }
    })

    typeFixed.isObject({}) // true
    type.isNumber(NaN) // true
    type.isRegExp(/abc/) // true
    ```
    ```js
    let obj = {
      p: 123
    };
    obj.hasOwnProperty('p') // true
    obj.hasOwnProperty('toString') // false
    // Object.prototype.hasOwnProperty方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。
    ```
## 面向对象
  * new
    * 对象是什么？
      1. 对象是单个事物的抽象
      2. 对象是一个容器，封装了属性（property）和方法（method）
          - 属性是对象的状态，方法是对象的行为（完成某种任务）
    构造函数
      * 对于JS来讲，对象体系是基于构造函数（constructor）和原型链（prototype）
    ```js
    let Salvatore = function() {
      this.status = '心态永远年轻'
    }
    ```
    从上可以看出，构造韩式就是一个普通函数，但是有自己的特征和用法，Salvatore就是构造函数，为了与普通函数区别，构造函数名字的第一个字母通常大写。构造函数的特点有两个。
      1. 函数体内部的this关键字，代表了所要生成的对象实例（也可以说是，谁来new它他就是指向谁，关于this的问题马上就会细细了解的）
      2. 生成对象的时候，必须使用new命令
    * 如何使用new
    ```js
    let Salvatore = function() {
      this.status = '心态永远年轻'
    }
    let xuanliao = new Salvatore()
    xuanliao.status // '心态永远年轻'
    // 再对象内部使用局部的严格模式，如果完了使用new命令直接调用回报错
    function Salvatore (name,age){
      'use strict'
      this._name = name
      this._age = age
    }
    Salvatore() // error
    // 或者利用new的target判断是否是new的对象
    function Salvatore (name,age) {
      if (new.target === Salvatore) {
        return new Error('请使用new命令声明对象！')
      }
      this._name = name
      this._age = age
    }
    // 上面的方法是给出报错信息，让开发者能够察觉，一下还有一种办法解决new的问题
    function Salvatore (name,age) {
      if (!(this instanceof Salvatore)) { // 在用! || 这样的运算符的时候一定看好范围，是否需要括号
        return new Salvatore(name,age)
      }
      this._name = name
      this._age = age
    }
    Salvatore('xuanliao', 25) // 可以正常使用
    new Salvatore('xuanliao', 25) // 也能够使用
    ```
    * new命令的原理
      * 使用new命令时，4步走
        1. 创建一个空对象，作为将要返回的对象实例。
        2. 将这个空对象的原型，指向构造函数的prototype属性。
        3. 将这个空对象赋值给函数内部的this关键字。
        4. 开始执行构造函数内部的代码。
        <!-- todo: 用代码实现 -->
        ```js
          function _new(constructor, params) {
            let args = [].slice.call(arguments) // 将对象转化成数组
            let constructor = args.shift() // 将构造函数取出
            let context = Object.create(constructor.prototype) // 创造一个空对象，继承构造函数的prototype的属性
            let result = constructor.apply(context, args)
            return (typyof result === 'object' && result != null) ? result : context
          }
          let actore = _new(Salvatore,'xuanliao',25)
        ```
        - 对于四步走我的理解是：先生成一个空对象，然后把关于所有this的操作，属性，方法，全部挂在空对象上面，也就是把构造函数的this指向空对象
        - 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。
        ```js
            let Salvatore = function () {
            this.price = 1000;
            return 1000;
          };
          (new Salvatore()) === 1000 // false
          // 想起分装vue中的Axios中的return new Promise()
        ```
    * 利用Object.create()创建实例对象
    ```js
    let sa = {
      name:'xuanliao',
      age:25,
      say: function () {
        console.log(`我叫${this.name},我今年${this.age}`)
      }
    }
    let salvatore = Object.create(sa)
    salvatore.say() // 我叫xuanliao,我今年25
    // 对象sa是salvatore的模板，后者继承了前者的属性和方法。
    ```
  * this
  * 继承
  * Object对象的相关方法
  * 严格模式

<back-to-top />