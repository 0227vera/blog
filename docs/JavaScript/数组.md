# 数组
常用的数组方法，用星号多少来表示我平常用的多少
## 1.push()，pop()  （**）
 * push往数组后面推入一个或者多个数据-------返回数组长度
 * pop往数组里面推出最后一个数据--------数组的最后一个元素
    * 以上两种方法都会改变数组长度，当两着结合使用的时候构成后进先出的原则 (两者不具有链式操作的功能，从返返回值就可以看出)
 ```js
  let a = []
  a.push(1,2,3,4,5) // 5
  a // [1,2,3,4,5]
  a.pop() // 5

  // 使用pop的一个小例子 ，根据文件名获取文件类型
  let filename = 'xx.hhh.heihgei.jpg'
  let type = filename.split('.').pop()
 ```
  * 有关空的相关情况
  ```js
  let b = []
  b.push(2,4,5,)
  b // [2,4,5]
  [].pop() // undefined 不报错
  ```


## 2.shift()，unshift() （*）

这两位兄弟就和之前的两哥们可以理解是相反的，但是他们也是改变数组长度的

  *  shift() 把数组的第一个元素推出------返回数组的第一个元素
  *  unshift() 在数组的前面推入数据------返回数组的长度
  ```js
  // 直接说shift的一个应用，在实现new命名的时候
  function _new(){
    let args = [].slice.call(arguments)
    let constructor = args.shift() // 将构造函数推出来
    let context = Object.create(constructor.prototype)
    let result = constructor.apply(constructor,args)
    return  (typeof result === 'object' && result !=null) ? result : context
  }
  // 使用shift()方法清空一个数组
  let list = [1,2,3,4,5,6]
  while(list.shift()){ // 可以看出[].shift() 返回undefined 
    list.shift()
  }
  list // []
  // 回头来讲这种方法是不可靠的，如果数组中有false或者 x == false 的x都是可以终止循环的，可以自己写两种情况试一下
  ```
## 3.join() （*）
  * join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。
  ```js
  let a = [1, 2, 3, 4];
  a.join(' ') // '1 2 3 4'
  a.join(' | ') // "1 | 2 | 3 | 4"
  a.join() // "1,2,3,4"
  ```
  * 特殊情况的处理：如果数组成员是undefined或null或空位，会被转成空字符串。
  ```js
  [undefined, null].join('#') // '#'
  ['a',, 'b'].join('-') // 'a--b'
  ```
  * 通过call方法，这个方法也可以用于字符串或类似数组的对象。
  ```js
  Array.prototype.join.call('hello', '-') // "h-e-l-l-o"
  let obj = { 0: 'a', 1: 'b', length: 2 };
  Array.prototype.join.call(obj, '-') // 'a-b'
  // 在这个地方是不是将类数组对象转化真正的数组除了Array.prototype.slice.call(objArr)以外也可以使用join和split的结合使用
  Array.prototype.join.call(obj, '-').split('-') // ?
  ```
## 4.concat() （**）
  * concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。
  ```js
  ['hello'].concat(['world'])
  // ["hello", "world"]
  ['hello'].concat(['world'], ['!'])
  // ["hello", "world", "!"]
  [].concat({a: 1}, {b: 2})
  // [{ a: 1 }, { b: 2 }]
  [2].concat({a: 1})
  // [2, {a: 1}]
  [1, 2, 3].concat(4, 5, 6)
  // [1, 2, 3, 4, 5, 6]
  ```
  ```js
  // 利用数组的concat()方法对数组进行降维操作 N维 ----> 1维
   function down(arr){
    return isMulti(arr) ? down(Array.prototype.concat.apply([],arr)) : arr
  }
  function isMulti (arr){
    let result = false
    arr.forEach(item => {
      if(isArray(item)){
        result = true
      }
    })
    return result
  }
  function isArray(type){
    return Object.prototype.toString.call(type).match(/\[object (.*?)\]/)[1].toLowerCase() === 'array'
  }
  ```
## 5.reverse()
  * reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。
  ```js
  // 一个典型的例子，将字符串颠倒
  function str_reverse(str){
    return str.split('').reverse().join('')
  }
  str_reverse('123456789') // 987654321
  ```
## 6.slice()
  slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。
  ```
  arr.slice(start, end);
  ```
  * 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。
  ```js
  let a = ['a', 'b', 'c'];
  a.slice(0) // ["a", "b", "c"]
  a.slice(1) // ["b", "c"]
  a.slice(1, 2) // ["b"]
  a.slice(2, 6) // ["c"]
  a.slice() // ["a", "b", "c"]
  // 参数可以为负数
  a.slice(-2) // ["b", "c"]
  a.slice(-2, -1) // ["b"]
  // 参数超出范围
  a.slice(4) // []
  a.slice(2, 1) // []
  ```
  * 在之前已经说到过的一个应用
  ```js
    Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })
    // ['a', 'b']
    Array.prototype.slice.call(document.querySelectorAll("div"));
    Array.prototype.slice.call(arguments);  
  ```
## 7.splice() （**）
splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。
```js
arr.splice(start, count, addElement1, addElement2, ...);
```
* splice()可以做数组任意位置的增加和删除
```js
// 删除
let a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.splice(4, 2) // ["e", "f"]
a // ["a", "b", "c", "d"]
```
```js
// 增加
let a = [1, 1, 1];
a.splice(1, 0, 2) // []
a // [1, 2, 1, 1]
```
```js
// 只传一个参数
let a = [1, 2, 3, 4];
a.splice(2) // [3, 4]
a // [1, 2] // 参数也可以为负数
```
## 8.sort()
sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。所以通常我们会去改写他
```js
[10111, 1101, 111].sort(function (a, b) {
  return a - b;
})
```
```js
[
  { name: "张三", age: 30 },
  { name: "李四", age: 24 },
  { name: "王五", age: 28  }
].sort(function (o1, o2) {
  return o1.age - o2.age;
})
```
## 9.map() （***）
map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。 原数组不改变，返回数组的数组长度不变
```js
[
  {uid:'dfa',name:'xx',id:'435dasfsa434'},
  {uid:'fg',name:'yy',id:'qrafasfq345tq34'},
  {uid:'gafdg',name:'zz',id:'43qe4tasfawrq34r'},
].map(item => item.id)
```
```js
let arr = ['a', 'b', 'c'];

[1, 2].map(function (e) {
  return this[e];
}, arr)
// ['b', 'c']
```

## 10.forEach() （***）
forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。
* 在说forEach之前，先简单的用js实现一些forEach,能够懂这个原理就自然能够回使用forEach
```js
Array.prototype._forEach=function(a,b){
  for(let i = 0; i < this.length; i++){
    a.call(b,this[i],i,this) // 将a的上下文指向b，forEach中的三个参数分别是当前值，当前序号，数组本身
  }
}
```
## 11.filter() （***）
filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。

它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。

filter返回的新数组的长度是变化的，分清楚filter和map的区别
```js
let obj = { MAX: 3 };
let myFilter = function (item) {
  if (item > this.MAX) return true;
};
let arr = [2, 8, 3, 4, 1, 3, 2, 9];
arr.filter(myFilter, obj) // [8, 4, 9]
```
## 12.some()，every()
这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。

some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。

```js
var arr = [1, 2, 3, 4, 5];
arr.some(function (elem, index, arr) {
  return elem >= 3;
});
// true
arr.every(function (elem, index, arr) {
  return elem >= 3;
});
// false
```
>注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。
## 13.reduce()，reduceRight()
reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。

这两个方法在es5的时候没有用过，做统计时候特别好用，之后的开发过程中会尝试使用，也推荐使用
```js
// 累加
[1, 2, 3, 4, 5].reduce( (a, b) => a + b ) // 15
[1, 2, 3, 4, 5].reduce( (a, b) => a + b , 10 ) // 25 // a的初始值是10在挨个累加，最后的出的是25
// 对于空数组
[].redice( (a,b) => a+b ) // 
```
reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。

1. 累积变量，默认为数组的第一个成员
2. 当前变量，默认为数组的第二个成员
3. 当前位置（从0开始）
4. 原数组

```js
// 实际应用 求数组长度最大的元素
let findLongest = entries =>  entries.reduce( (longest, entry) => entry.length > longest.length ? entry : longest, '');
findLongest(['aaa', 'bb', 'c']) // "aaa"
```
## 14.indexOf()，lastIndexOf() （**）
indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。（lastIndexOf先后顺序的问题，这个地方就只说indexOf，lastIndexOf使用同理）

```js
let a = ['a', 'b', 'c'];
a.indexOf('a') // 0
a.indexOf('d') // -1
// 在开发过程中会很有作用
~a.indexOf('a') // 非0 ------------> !!~a.indexOf('a') // true 在数组里面存在a
~a.indexOf('d') // 0---------------> !!~a.indexOf('d') // false在数组里面不存在d
```
~ 会将-1--->0,其他的转化为非0，当然肯定有他自己的转化规则，这个地方不去详细说明


## 15.链式操作 （***）
上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。
```js
let users = [
  {name: 'tom', email: 'tom@example.com'},
  {name: 'peter', email: 'peter@example.com'}
];

users
.map( user => user.email)
.filter( email = /^t/.test(email))
.forEach( email => {
  console.log(email)
})
// "tom@example.com"
```
数组的很多方法和es6联合起来使用看起来会简单很多，可以使用链式操作的方法主要看数组的返回值就好，如果返回的是数组则可以使用链式操作，在这儿也特别强调自己一编们一定要注意每一种方法数组的返回值，使用逆向思维去使用数组会清楚很多

[参考文档](https://wangdoc.com/javascript/stdlib/array.html)
<back-to-top />